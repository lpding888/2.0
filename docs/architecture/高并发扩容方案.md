# 高并发扩容方案（支持60+用户）

## 当前架构容量

### 理论上限
- ✅ 架构设计：支持无限并发（每用户独立容器）
- ✅ 数据库：支持几百并发连接

### 实际瓶颈
1. **云函数并发配额**：默认20-50实例/函数
2. **AI API速率限制**：免费版15 RPM，付费版360 RPM

---

## 方案1：升级配额（推荐，最简单）

### 1.1 升级云函数配额
**操作路径**：云开发控制台 → 环境设置 → 配额管理

**配置项**：
```
photography-worker:
  - 并发实例数：100（从默认20提升）
  - 内存：256MB（保持）
  - 超时时间：60s（保持）

fitting-worker:
  - 并发实例数：100（从默认20提升）
  - 内存：256MB（保持）
  - 超时时间：60s（保持）
```

**成本**：约 ¥0.000110/GB·秒（按实际使用计费）

**效果**：
- 支持100个用户同时生成
- 超出100会排队等待

---

### 1.2 升级AI API配额
**Gemini API付费版**：
- 360 RPM（支持60并发）
- $7/月 或按量计费

**或使用多个API密钥轮询**：
```javascript
// cloudfunctions/photography-worker/modules/aiCaller.js
// 添加API密钥池
const API_KEYS = [
  process.env.GEMINI_API_KEY_1,
  process.env.GEMINI_API_KEY_2,
  process.env.GEMINI_API_KEY_3,
  // 3个免费API密钥 = 45 RPM
]

// 轮询选择
const key = API_KEYS[Math.floor(Math.random() * API_KEYS.length)]
```

**效果**：
- 3个免费密钥 = 45 RPM（支持45并发）
- 10个免费密钥 = 150 RPM（支持150并发）

---

## 方案2：任务队列 + 限流（推荐，更稳定）

### 架构改造

#### 当前流程（可能失败）：
```
60个用户同时点击 → 60个worker同时启动 → 部分失败
```

#### 改造后流程（排队处理）：
```
60个用户同时点击 → 全部立即返回task_id ✅
  ↓
任务队列（按时间排序）
  ↓
队列处理器（限制同时处理数=20）
  ↓ 启动20个worker
  ↓ 完成后继续处理队列中的下20个
  ↓ 所有任务最终都会完成 ✅
```

### 实现步骤

#### 2.1 保持现有入口（已完成）
```javascript
// cloudfunctions/photography/index.js
// 不需要修改，用户立即收到task_id
return {
  success: true,
  data: { task_id: taskId },
  message: '任务已提交，正在排队处理...'
}
```

#### 2.2 创建队列处理器
**新建云函数**：`cloudfunctions/queue-manager/index.js`

```javascript
const cloud = require('wx-server-sdk')
cloud.init({ env: cloud.DYNAMIC_CURRENT_ENV })
const db = cloud.database()

// 配置：同时处理的最大任务数
const MAX_CONCURRENT_TASKS = 20

exports.main = async (event, context) => {
  console.log('🔄 队列管理器启动')

  // 1. 查询pending状态的任务（按创建时间排序）
  const pendingTasks = await db.collection('task_queue')
    .where({
      status: 'pending',
      state: 'pending'
    })
    .orderBy('created_at', 'asc')
    .limit(100)
    .get()

  console.log(`📊 队列中任务数: ${pendingTasks.data.length}`)

  // 2. 查询当前正在处理的任务数
  const processingTasks = await db.collection('task_queue')
    .where({
      status: 'processing'
    })
    .count()

  const currentProcessing = processingTasks.total
  const availableSlots = MAX_CONCURRENT_TASKS - currentProcessing

  console.log(`🎰 当前处理中: ${currentProcessing}, 可用槽位: ${availableSlots}`)

  if (availableSlots <= 0) {
    console.log('⏸️ 已达到并发上限，等待下次执行')
    return { message: 'Queue full, waiting...' }
  }

  // 3. 启动可用数量的任务
  const tasksToStart = pendingTasks.data.slice(0, availableSlots)

  for (const task of tasksToStart) {
    try {
      // 更新为processing状态
      await db.collection('task_queue')
        .doc(task._id)
        .update({
          data: {
            status: 'processing',
            state: 'ai_calling',
            updated_at: new Date()
          }
        })

      // 启动对应的worker
      const workerName = task.type === 'photography' ? 'photography-worker' : 'fitting-worker'

      await cloud.callFunction({
        name: workerName,
        data: {
          taskId: task._id,
          originalEvent: task.params,
          wxContext: { OPENID: task.user_openid }
        }
      })

      console.log(`✅ 已启动任务: ${task._id} (${workerName})`)

    } catch (error) {
      console.error(`❌ 启动任务失败: ${task._id}`, error)

      // 标记失败并退还积分
      await db.collection('task_queue')
        .doc(task._id)
        .update({
          data: {
            status: 'failed',
            error: error.message,
            updated_at: new Date()
          }
        })
    }
  }

  return {
    success: true,
    started: tasksToStart.length,
    remaining: pendingTasks.data.length - tasksToStart.length
  }
}
```

#### 2.3 定时触发队列处理器
**配置定时触发器**：
- 云开发控制台 → queue-manager → 触发器
- 类型：定时触发器
- Cron表达式：`0/30 * * * * * *`（每30秒执行一次）

**或使用云函数互相调用**：
```javascript
// cloudfunctions/photography-worker/index.js
// 在任务完成后触发队列处理器
await cloud.callFunction({
  name: 'queue-manager',
  data: {}
})
```

#### 2.4 修改photography.generate()（可选）
如果想直接使用队列，不需要修改代码，因为：
- 任务已经创建到task_queue
- queue-manager会自动处理pending任务
- 用户体验不变（立即收到task_id，轮询进度）

---

## 方案3：混合方案（最佳实践）

### 配置
1. 升级云函数配额到50并发
2. 配置队列管理器（MAX_CONCURRENT_TASKS = 40）
3. 使用3个AI API密钥轮询

### 效果
```
0-40用户: 立即处理 ✅（40并发槽位）
41-60用户: 排队30秒内启动 ⏳（队列自动处理）
60+用户: 排队1-2分钟启动 ⏳（等待前面任务完成）
```

### 用户体验
- ✅ 所有用户都能立即提交（秒级响应）
- ✅ 前40人几乎立即开始生成
- ✅ 后20人等待30秒-1分钟
- ✅ 没有"请求失败"错误
- ✅ 前端进度条显示"排队中..."

---

## 推荐实施顺序

### 阶段1：快速验证（无需修改代码）
1. 测试当前架构的实际并发能力
2. 模拟10-20个并发用户
3. 观察是否有失败

### 阶段2：升级配额（1小时）
1. 云开发控制台提升并发配额到50-100
2. 配置多个AI API密钥（如果需要）
3. 重新测试并发能力

### 阶段3：队列管理器（2-3小时）
如果阶段2仍不够：
1. 创建queue-manager云函数
2. 配置定时触发器
3. 测试排队逻辑

---

## 成本估算

### 60人同时使用，每天运行1次

**云函数费用**：
```
60次 × 60秒 × 256MB = 921,600 MB·秒
921,600 × 0.000110元/GB·秒 ÷ 1024 = ¥0.99/天
```

**AI API费用**（Gemini免费版）：
```
60次生成/天 < 1500次/天 = 免费 ✅
```

**总成本**：约 ¥30/月

### 如果使用付费AI API
```
Gemini Pro: $0.005/次
60次/天 × 30天 = 1800次
1800 × $0.005 = $9/月（约¥65）
```

---

## 监控和告警

### 关键指标
1. 云函数并发实例数
2. AI API错误率（429错误）
3. task_queue pending任务数量
4. 平均任务完成时间

### 告警规则
```
IF pending_tasks > 50: 发送告警（队列积压）
IF error_rate > 10%: 发送告警（API限流）
IF processing_time > 180s: 发送告警（处理超时）
```

---

## 总结

### 当前状态
- ✅ 架构支持：无限并发（理论上）
- ⚠️ 配额限制：20-50并发（实际）

### 快速方案（支持60人）
1. **立即可做**：升级云函数配额到100（云开发控制台操作）
2. **15分钟**：配置3个AI API密钥轮询（环境变量）
3. **预期效果**：支持60人并发，成本约¥30/月

### 稳定方案（支持100+人）
1. **2-3小时**：实现queue-manager + 定时触发器
2. **预期效果**：支持无限排队，所有任务最终完成
3. **用户体验**：前40人立即处理，其他排队（显示进度）

需要我帮你实现哪个方案？

# 生图流程分析和改造计划

## 📊 当前流程（梳理完成）

### 完整调用链

```
1. 小程序前端
   ↓ (wx.cloud.callFunction)

2. photography 云函数 (60秒超时)
   - 验证用户积分
   - 扣除积分
   - 创建 task_queue 记录 (status='pending')
   - 创建 works 记录 (status='pending')
   - 异步调用 photography-worker (不等待)
   - 立即返回 task_id 给前端

3. photography-worker 云函数 (60秒超时)
   - 更新状态为 'processing'
   - 获取场景信息
   - 处理上传的图片（base64转换）
   - 生成AI提示词
   - 调用 aimodels.createGenerationTask
   - 等待 aimodels 返回 ❌ 这里会阻塞

4. aimodels 云函数 (60秒超时)
   - action: 'createGenerationTask'
   - 执行 WorkflowOrchestrator.executeGenerationWorkflow
     a. 下载并处理输入图片
     b. 选择AI模型
     c. 调用 AICaller.generateImages ❌ 这里可能超时
        - 调用外部AI服务 (60秒超时)
        - 等待AI响应
     d. 添加水印
     e. 上传到云存储
     f. 调用 AICaller.handleLargeAIResult
        - 处理图片上传
        - 更新 works 和 task_queue 状态为 'completed'
   - 如果失败，调用 AICaller.handleFailedAI
     - 退还积分
     - 更新状态为 'failed'

5. 前端轮询
   - 定时调用 photography.getProgress 查询任务状态
```

### 🔴 核心问题

1. **60秒限制链**：`photography-worker (60s)` → `aimodels (60s)` → `AICaller.timeout (60s)`
2. **同步等待**：photography-worker 等待 aimodels 完成，aimodels 等待 AI 服务响应
3. **AI服务响应时间**：图像生成通常需要 30-120 秒，经常超过 60 秒
4. **ai-callback 未使用**：已创建但没有被调用

### ✅ 目前可用的云函数

- `photography` - 前端入口
- `photography-worker` - 任务处理
- `aimodels` - AI调用和工作流
- `ai-callback` - 回调处理（未使用）

---

## 🎯 改造方案设计

### 方案：数据库触发器 + 定时触发器组合

#### 核心思路

将耗时的 AI 处理从云函数调用链中分离出来，改用触发器异步处理。

#### 新流程架构

```
1. 小程序前端
   ↓
2. photography 云函数 (60秒)
   - 扣积分
   - 创建 task_queue (status='pending') ← 触发数据库触发器
   - 创建 works (status='pending')
   - 立即返回
   ✅ 不再调用 photography-worker

3. 【数据库触发器】自动触发
   ↓ (监听 task_queue 创建事件)

4. task-processor 云函数 (支持定时触发器配置)
   - 检查任务状态 (只处理 'pending')
   - 更新状态为 'processing'
   - 执行完整的 AI 工作流（不受60秒限制）
     a. 处理图片
     b. 选择模型
     c. 调用 AI 服务（充足时间）
     d. 添加水印
     e. 上传存储
     f. 更新数据库

5. 【定时触发器】兜底机制
   - 每 3 分钟运行一次
   - 查找卡住的任务 (processing > 10分钟)
   - 重新处理或标记失败

6. 前端
   - 监听 works 集合实时变化 (watch)
   - 实时更新进度
```

---

## 🏗️ 具体实施步骤

### 步骤 1：改造 ai-callback 为 task-processor

#### 1.1 重命名云函数

```bash
cd cloudfunctions
mv ai-callback task-processor
cd task-processor
```

#### 1.2 创建 config.json

```json
{
  "triggers": [
    {
      "name": "taskCleanup",
      "type": "timer",
      "config": "0 */3 * * * * *"
    }
  ]
}
```

**说明**：
- `name`: 触发器名称
- `type`: "timer" 定时触发器
- `config`: Cron 表达式，每3分钟运行一次（"0 */3 * * * * *"）

#### 1.3 修改 package.json

```json
{
  "name": "task-processor",
  "version": "1.0.0",
  "description": "异步任务处理器 - 支持数据库触发和定时触发",
  "main": "index.js",
  "dependencies": {
    "wx-server-sdk": "~2.6.3",
    "canvas": "^2.11.2"
  },
  "cloudbaseFunction": {
    "timeout": 60,
    "runtime": "Nodejs14.18",
    "memorySize": 512
  }
}
```

**注意**：timeout 只能设置为 60 秒，这是微信云函数的硬限制。

#### 1.4 重写 index.js

核心逻辑：

```javascript
const cloud = require('wx-server-sdk')
cloud.init({ env: cloud.DYNAMIC_CURRENT_ENV })
const db = cloud.database()

exports.main = async (event, context) => {
  console.log('🚀 task-processor 被触发:', {
    triggerName: event.triggerName,
    docId: event.docId,
    eventType: event.eventType
  })

  try {
    // 判断触发类型
    if (event.triggerName === 'taskCleanup') {
      // 定时触发器 - 处理卡住的任务
      return await handleTimerTrigger()
    } else if (event.docId) {
      // 数据库触发器 - 处理新任务
      return await handleDatabaseTrigger(event)
    } else {
      // 手动调用
      return { success: false, message: '请通过触发器调用' }
    }
  } catch (error) {
    console.error('❌ task-processor 执行失败:', error)
    return { success: false, message: error.message }
  }
}

// 处理数据库触发器
async function handleDatabaseTrigger(event) {
  const { docId, doc, eventType } = event

  console.log('📥 数据库触发器事件:', eventType)

  // 只处理新创建的 pending 任务
  if (eventType !== 'create') {
    console.log('⏭️ 跳过非创建事件')
    return { success: true, message: '跳过' }
  }

  if (!doc || doc.status !== 'pending') {
    console.log('⏭️ 跳过非 pending 任务')
    return { success: true, message: '跳过' }
  }

  console.log('🎯 开始处理任务:', docId)

  // 调用 aimodels 执行 AI 生成工作流
  try {
    const result = await cloud.callFunction({
      name: 'aimodels',
      data: {
        action: 'generateFromFileIds',
        taskId: docId,
        imageIds: doc.params.images || [],
        prompt: await generatePrompt(doc),
        parameters: doc.params.parameters || {},
        type: doc.type
      }
    })

    console.log('✅ AI工作流完成:', result)
    return { success: true, taskId: docId }

  } catch (error) {
    console.error('❌ AI工作流失败:', error)

    // 更新任务状态为失败
    await db.collection('task_queue').doc(docId).update({
      data: {
        status: 'failed',
        error: error.message,
        updated_at: new Date()
      }
    })

    return { success: false, taskId: docId, error: error.message }
  }
}

// 处理定时触发器（兜底机制）
async function handleTimerTrigger() {
  console.log('⏰ 定时触发器运行 - 检查卡住的任务')

  const _ = db.command
  const tenMinutesAgo = new Date(Date.now() - 10 * 60 * 1000)

  // 查找卡住的任务
  const result = await db.collection('task_queue')
    .where({
      status: _.in(['pending', 'processing']),
      created_at: _.lt(tenMinutesAgo)
    })
    .limit(5)
    .get()

  console.log(`🔍 发现 ${result.data.length} 个卡住的任务`)

  for (const task of result.data) {
    console.log('🔄 重新处理任务:', task._id)

    // 重新提交到 aimodels
    await cloud.callFunction({
      name: 'aimodels',
      data: {
        action: 'generateFromFileIds',
        taskId: task._id,
        imageIds: task.params.images || [],
        prompt: await generatePrompt(task),
        parameters: task.params.parameters || {},
        type: task.type
      }
    }).catch(error => {
      console.error('重试失败:', error)
    })
  }

  return { success: true, processed: result.data.length }
}

// 生成提示词
async function generatePrompt(task) {
  // 调用 prompt 云函数生成提示词
  const result = await cloud.callFunction({
    name: 'prompt',
    data: {
      action: 'generatePrompt',
      type: task.type,
      parameters: task.params.parameters || {},
      sceneInfo: task.params.sceneId ? await getSceneInfo(task.params.sceneId) : {}
    }
  })

  if (result.result && result.result.success) {
    return result.result.data.prompt
  }

  return '生成时尚摄影照片'
}

async function getSceneInfo(sceneId) {
  try {
    const result = await db.collection('scenes').doc(sceneId).get()
    return result.data || {}
  } catch (error) {
    console.warn('获取场景失败:', error)
    return {}
  }
}
```

---

### 步骤 2：简化 photography 云函数

移除对 photography-worker 的调用，直接创建任务即可。

```javascript
// photography/index.js - generatePhotography 函数

async function generatePhotography(event, wxContext) {
  // ... 验证和扣积分逻辑保持不变 ...

  // 生成任务ID
  const taskId = generateTaskId()

  // 创建任务记录 - 数据库触发器会自动处理
  await db.collection('task_queue').add({
    data: {
      _id: taskId,
      user_openid: OPENID,
      type: 'photography',
      status: 'pending',  // ← 触发器监听此状态
      params: {
        images: images || [],
        parameters: parameters || {},
        sceneId: sceneId || null,
        count: count || 1
      },
      created_at: new Date(),
      updated_at: new Date()
    }
  })

  // 创建作品记录
  const workResult = await db.collection('works').add({
    data: {
      user_openid: OPENID,
      type: 'photography',
      status: 'pending',
      task_id: taskId,
      images: [],
      parameters: {
        ...parameters,
        original_images: images,
        scene_id: sceneId,
        count: count
      },
      is_favorite: false,
      created_at: new Date(),
      updated_at: new Date()
    }
  })

  // ❌ 删除这部分 - 不再调用 photography-worker
  // cloud.callFunction({
  //   name: 'photography-worker',
  //   data: { ... }
  // })

  // 立即返回
  return {
    success: true,
    data: {
      task_id: taskId,
      work_id: workResult._id
    },
    message: '任务已提交，正在生成中...'
  }
}
```

---

### 步骤 3：配置数据库触发器（手动操作）

⚠️ **重要**：这一步需要在微信云开发控制台手动配置

#### 3.1 进入云开发控制台

1. 打开微信开发者工具
2. 点击 "云开发" 按钮
3. 在浏览器中打开云开发控制台

#### 3.2 配置触发器

1. 进入：**云开发控制台** → **云函数**
2. 找到 `task-processor` 云函数
3. 点击 "触发器" 标签
4. 点击 "添加触发器"

配置参数：
- **触发器类型**：数据库触发器
- **集合名称**：`task_queue`
- **触发条件**：文档创建
- **目标云函数**：`task-processor`

注意事项：
- 数据库触发器无法设置过滤条件，会在每次创建时都触发
- 需要在代码中判断 `status === 'pending'` 来过滤
- 触发器配置后立即生效

---

### 步骤 4：前端添加实时监听（可选但推荐）

```javascript
// miniprogram/pages/works/works.js

onLoad() {
  this.loadWorks()
  this.startRealtimeWatch()
},

onUnload() {
  this.stopRealtimeWatch()
},

// 启动实时监听
startRealtimeWatch() {
  const db = wx.cloud.database()
  const app = getApp()

  if (!app.globalData.userInfo?.openid) {
    return
  }

  this.watcher = db.collection('works')
    .where({
      user_openid: app.globalData.userInfo.openid
    })
    .watch({
      onChange: (snapshot) => {
        snapshot.docChanges.forEach(change => {
          if (change.queueType === 'update') {
            this.updateWorkInList(change.doc)

            // 如果作品完成，显示提示
            if (change.doc.status === 'completed') {
              wx.showToast({ title: '作品生成完成', icon: 'success' })
            }
          }
        })
      },
      onError: (err) => {
        console.error('监听失败:', err)
      }
    })
},

stopRealtimeWatch() {
  if (this.watcher) {
    this.watcher.close()
  }
}
```

---

## 📝 部署清单

### 1. 代码修改

- [x] 重命名 `ai-callback` → `task-processor`
- [ ] 创建 `task-processor/config.json`
- [ ] 修改 `task-processor/index.js`
- [ ] 修改 `task-processor/package.json`
- [ ] 简化 `photography/index.js`
- [ ] （可选）修改 `works.js` 添加实时监听

### 2. 云函数部署

```powershell
# 部署 task-processor
cd cloudfunctions/task-processor
npm install
# 右键点击 task-processor → 上传并部署：云端安装依赖

# 部署 photography
cd ../photography
# 右键点击 photography → 上传并部署：云端安装依赖
```

### 3. 控制台配置

- [ ] 配置 task-processor 的定时触发器
- [ ] 配置 task-processor 的数据库触发器（监听 task_queue 创建）

### 4. 测试验证

- [ ] 测试提交任务
- [ ] 观察数据库触发器是否触发
- [ ] 观察定时触发器日志
- [ ] 验证生图功能正常
- [ ] 验证积分扣除和退还
- [ ] 验证前端实时更新

---

## ⚠️ 注意事项

### 1. 云函数超时限制

**微信云函数硬性限制为 60 秒**，无法修改。但：
- 定时触发器每3分钟运行一次，可以持续处理
- 数据库触发器会立即响应任务创建
- 即使单次执行超时，定时器会重试

### 2. 数据库触发器限制

- 无法设置触发条件过滤（如 `status === 'pending'`）
- 需要在代码中判断状态
- 避免重复处理

### 3. AI 调用超时

虽然云函数限制60秒，但：
- `aimodels` 内部的 `AICaller.timeout` 设置为 60 秒
- 如果 AI 服务响应超过 60 秒，会超时
- 解决方案：依赖定时触发器重试机制

### 4. 成本考虑

- 定时触发器每3分钟运行，每天运行 480 次
- 数据库触发器按实际任务数触发
- 需要评估云函数调用量配额

---

## 🎉 预期效果

实施后：
- ✅ 任务提交立即返回，不阻塞用户
- ✅ 数据库触发器自动处理新任务
- ✅ 定时触发器兜底处理卡住的任务
- ✅ 前端实时监听，0延迟更新
- ✅ 即使 AI 服务响应慢，也有重试机制
- ✅ 生图功能稳定可用

---

## 📅 实施时间表

- **准备阶段**（10分钟）：代码修改和测试
- **部署阶段**（5分钟）：上传云函数
- **配置阶段**（5分钟）：控制台配置触发器
- **验证阶段**（10分钟）：功能测试

**总计**：约 30 分钟

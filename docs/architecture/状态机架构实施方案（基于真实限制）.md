# 状态机架构实施方案（基于真实限制）

## 📋 基于搜索结果的事实

### ✅ 确认的限制

1. **微信云开发云函数**：
   - 最大超时：**60秒**（硬性限制，无法突破）
   - 可配置范围：3-60秒
   - 默认超时：3秒

2. **腾讯CloudBase规则**：
   - timeout < 20秒：同步调用，日志限制4KB
   - timeout >= 20秒：异步调用，日志限制6MB

3. **支持的异步机制**：
   - ✅ 定时触发器（Cron表达式）
   - ✅ 数据库触发器
   - ✅ 延时调用（addDelayedFunctionTask）
   - ✅ `context.callbackWaitsForEmptyEventLoop = false`

4. **不支持的功能**：
   - ❌ AWS Step Functions 类型的状态机服务
   - ❌ 超过60秒的云函数执行
   - ❌ 内置的工作流编排

---

## 🎯 解决方案：自实现状态机

### 核心思路

**将长时任务分解为多个独立步骤，每步都在60秒内完成**

```
状态流转（每个状态独立处理）:

pending
   ↓ (30秒内)
downloading
   ↓ (30秒内)
downloaded
   ↓ (立即)
ai_calling
   ↓ (轮询检查)
ai_completed
   ↓ (30秒内)
watermarking
   ↓ (30秒内)
uploading
   ↓
completed

每个状态由定时触发器推进，互不阻塞
```

---

## 🏗️ 架构设计

### 1. 状态定义

```javascript
const TaskStates = {
  PENDING: 'pending',              // 待处理
  DOWNLOADING: 'downloading',      // 下载图片中
  DOWNLOADED: 'downloaded',        // 图片已下载
  AI_CALLING: 'ai_calling',       // AI调用中
  AI_PROCESSING: 'ai_processing', // AI处理中
  AI_COMPLETED: 'ai_completed',   // AI完成
  WATERMARKING: 'watermarking',   // 添加水印
  UPLOADING: 'uploading',         // 上传中
  COMPLETED: 'completed',         // 完成
  FAILED: 'failed'                // 失败
}
```

### 2. 状态转换规则

```javascript
// 自动转换（由state-processor处理）
pending → downloading (立即)
downloading → downloaded (完成后)
downloaded → ai_calling (立即)
ai_calling → ai_processing (提交后)
ai_processing → ai_completed (AI完成后)
ai_completed → watermarking (立即)
watermarking → uploading (完成后)
uploading → completed (完成后)

// 错误转换
任何状态 → failed (出错时)
```

### 3. task_queue 数据结构

```javascript
{
  _id: 'task_xxx',
  user_openid: 'xxx',
  type: 'photography',
  status: 'pending',

  // 状态机相关
  state: 'pending',               // 当前状态
  state_data: {                   // 状态数据
    downloaded_images: [],        // 已下载的图片
    ai_task_id: null,            // AI任务ID
    ai_result: null,             // AI结果
    watermarked_images: [],      // 带水印的图片
    final_images: []             // 最终图片
  },

  // 重试和超时控制
  retry_count: 0,                 // 重试次数
  max_retries: 3,                 // 最大重试次数
  state_started_at: Date,        // 当前状态开始时间
  state_timeout: 300000,         // 状态超时（5分钟）

  // 原有字段
  params: { ... },
  created_at: Date,
  updated_at: Date
}
```

---

## 📝 实施步骤

### 步骤1: 创建状态处理器云函数

创建 `state-processor` 云函数，替代 `task-processor`

**文件结构**:
```
cloudfunctions/
  └─ state-processor/
      ├─ index.js              # 主入口
      ├─ config.json           # 定时触发器配置
      ├─ package.json
      └─ states/               # 状态处理器目录
          ├─ pending.js        # 处理 pending 状态
          ├─ downloading.js    # 处理 downloading 状态
          ├─ downloaded.js     # 处理 downloaded 状态
          ├─ ai_calling.js     # 处理 ai_calling 状态
          ├─ ai_processing.js  # 处理 ai_processing 状态
          ├─ ai_completed.js   # 处理 ai_completed 状态
          ├─ watermarking.js   # 处理 watermarking 状态
          ├─ uploading.js      # 处理 uploading 状态
          └─ base.js           # 基础状态处理类
```

### 步骤2: 实现状态处理器

#### config.json
```json
{
  "triggers": [
    {
      "name": "stateProcessor",
      "type": "timer",
      "config": "0 */30 * * * * *"
    }
  ]
}
```

#### index.js (核心逻辑)
```javascript
const cloud = require('wx-server-sdk')
cloud.init({ env: cloud.DYNAMIC_CURRENT_ENV })
const db = cloud.database()

// 导入状态处理器
const stateHandlers = {
  pending: require('./states/pending'),
  downloading: require('./states/downloading'),
  downloaded: require('./states/downloaded'),
  ai_calling: require('./states/ai_calling'),
  ai_processing: require('./states/ai_processing'),
  ai_completed: require('./states/ai_completed'),
  watermarking: require('./states/watermarking'),
  uploading: require('./states/uploading')
}

exports.main = async (event, context) => {
  console.log('🚀 state-processor 运行')

  try {
    const results = []

    // 处理每种状态的任务
    for (const [state, handler] of Object.entries(stateHandlers)) {
      const stateResults = await processState(state, handler)
      results.push(...stateResults)
    }

    console.log(`✅ 处理完成，共处理 ${results.length} 个任务`)
    return { success: true, processed: results.length, results }

  } catch (error) {
    console.error('❌ state-processor 执行失败:', error)
    return { success: false, message: error.message }
  }
}

async function processState(stateName, handler) {
  console.log(`📥 处理状态: ${stateName}`)

  try {
    // 查找该状态的任务（限制处理数量）
    const tasks = await db.collection('task_queue')
      .where({
        state: stateName,
        retry_count: db.command.lt(3)
      })
      .limit(10)
      .get()

    if (tasks.data.length === 0) {
      console.log(`⏭️ 没有 ${stateName} 状态的任务`)
      return []
    }

    console.log(`🎯 发现 ${tasks.data.length} 个 ${stateName} 任务`)

    const results = []

    // 并发处理（但每个任务独立）
    await Promise.allSettled(
      tasks.data.map(async (task) => {
        try {
          console.log(`🔄 处理任务 ${task._id}`)

          // 调用状态处理器
          const result = await handler.process(task, db, cloud)

          results.push({
            taskId: task._id,
            success: true,
            ...result
          })

          console.log(`✅ 任务 ${task._id} 处理完成`)

        } catch (error) {
          console.error(`❌ 任务 ${task._id} 处理失败:`, error)

          // 增加重试计数
          await db.collection('task_queue').doc(task._id).update({
            data: {
              retry_count: db.command.inc(1),
              last_error: error.message,
              updated_at: new Date()
            }
          })

          // 如果重试次数超限，标记为失败
          if ((task.retry_count || 0) >= 2) {
            await db.collection('task_queue').doc(task._id).update({
              data: {
                state: 'failed',
                status: 'failed',
                error: '重试次数超限',
                updated_at: new Date()
              }
            })

            // 退还积分
            await refundCredits(task)
          }

          results.push({
            taskId: task._id,
            success: false,
            error: error.message
          })
        }
      })
    )

    return results

  } catch (error) {
    console.error(`❌ 处理状态 ${stateName} 失败:`, error)
    return []
  }
}

async function refundCredits(task) {
  // 退还积分逻辑
  if (!task.user_openid || !task.params) return

  const credits = task.params.count || 1

  await db.collection('users')
    .where({ openid: task.user_openid })
    .update({
      data: {
        credits: db.command.inc(credits),
        total_consumed_credits: db.command.inc(-credits),
        updated_at: new Date()
      }
    })

  console.log(`💰 已退还 ${credits} 积分给用户 ${task.user_openid}`)
}
```

### 步骤3: 实现各状态处理器

#### states/base.js (基础类)
```javascript
class BaseStateHandler {
  constructor(stateName) {
    this.stateName = stateName
  }

  async updateState(taskId, newState, stateData, db) {
    await db.collection('task_queue').doc(taskId).update({
      data: {
        state: newState,
        state_data: stateData,
        state_started_at: new Date(),
        updated_at: new Date()
      }
    })

    // 同时更新 works
    await db.collection('works').where({ task_id: taskId }).update({
      data: {
        status: newState,
        updated_at: new Date()
      }
    })
  }

  async markFailed(taskId, error, db) {
    await db.collection('task_queue').doc(taskId).update({
      data: {
        state: 'failed',
        status: 'failed',
        error: error,
        updated_at: new Date()
      }
    })

    await db.collection('works').where({ task_id: taskId }).update({
      data: {
        status: 'failed',
        error: error,
        updated_at: new Date()
      }
    })
  }

  // 子类必须实现
  async process(task, db, cloud) {
    throw new Error('子类必须实现 process 方法')
  }
}

module.exports = BaseStateHandler
```

#### states/pending.js
```javascript
const BaseStateHandler = require('./base')

class PendingHandler extends BaseStateHandler {
  constructor() {
    super('pending')
  }

  async process(task, db, cloud) {
    console.log(`📥 处理 pending 任务: ${task._id}`)

    // pending → downloading
    // 初始化状态数据
    const stateData = {
      downloaded_images: [],
      ai_task_id: null,
      ai_result: null,
      watermarked_images: [],
      final_images: []
    }

    await this.updateState(task._id, 'downloading', stateData, db)

    return {
      message: 'Task moved to downloading state'
    }
  }
}

module.exports = new PendingHandler()
```

#### states/downloading.js
```javascript
const BaseStateHandler = require('./base')

class DownloadingHandler extends BaseStateHandler {
  constructor() {
    super('downloading')
  }

  async process(task, db, cloud) {
    console.log(`📥 下载图片: ${task._id}`)

    const imageIds = task.params.images || []

    if (imageIds.length === 0) {
      // 没有图片，直接跳到 downloaded
      await this.updateState(task._id, 'downloaded', {
        ...task.state_data,
        downloaded_images: []
      }, db)
      return { message: 'No images to download' }
    }

    const downloadedImages = []

    // 下载所有图片（限时操作）
    for (const imageId of imageIds) {
      try {
        const result = await cloud.downloadFile({
          fileID: imageId
        })

        // 检查是否为base64预处理模式
        const fileContent = result.fileContent.toString('utf8')
        let base64Data, mimeType

        if (fileContent.startsWith('data:image/')) {
          // Base64预处理模式
          const matches = fileContent.match(/^data:image\/([^;]+);base64,(.+)$/)
          if (matches) {
            mimeType = `image/${matches[1]}`
            base64Data = matches[2]
          }
        } else {
          // 传统模式
          base64Data = result.fileContent.toString('base64')
          mimeType = 'image/jpeg'
        }

        downloadedImages.push({
          fileId: imageId,
          base64Data: base64Data,
          mimeType: mimeType,
          size: base64Data.length
        })

      } catch (error) {
        console.error(`下载图片失败: ${imageId}`, error)
      }
    }

    // 更新状态为 downloaded
    await this.updateState(task._id, 'downloaded', {
      ...task.state_data,
      downloaded_images: downloadedImages
    }, db)

    return {
      message: `Downloaded ${downloadedImages.length} images`
    }
  }
}

module.exports = new DownloadingHandler()
```

#### states/downloaded.js
```javascript
const BaseStateHandler = require('./base')

class DownloadedHandler extends BaseStateHandler {
  constructor() {
    super('downloaded')
  }

  async process(task, db, cloud) {
    console.log(`📥 准备AI调用: ${task._id}`)

    // downloaded → ai_calling
    // 生成提示词
    const prompt = await this.generatePrompt(task, db, cloud)

    // 更新状态
    await this.updateState(task._id, 'ai_calling', {
      ...task.state_data,
      prompt: prompt
    }, db)

    return {
      message: 'Ready for AI calling'
    }
  }

  async generatePrompt(task, db, cloud) {
    // 获取场景信息
    let sceneInfo = {}
    if (task.params.sceneId) {
      try {
        const result = await db.collection('scenes').doc(task.params.sceneId).get()
        sceneInfo = result.data || {}
      } catch (error) {
        console.warn('获取场景失败:', error)
      }
    }

    // 调用 prompt 云函数
    try {
      const result = await cloud.callFunction({
        name: 'prompt',
        data: {
          action: 'generatePrompt',
          type: task.type,
          parameters: task.params.parameters || {},
          sceneInfo: sceneInfo
        }
      })

      if (result.result && result.result.success) {
        return result.result.data.prompt
      }
    } catch (error) {
      console.warn('生成提示词失败:', error)
    }

    // 返回默认提示词
    return '专业时尚摄影，展示服装。高质量摄影，专业打光，时尚风格，1024x1024分辨率。'
  }
}

module.exports = new DownloadedHandler()
```

#### states/ai_calling.js (关键！)
```javascript
const BaseStateHandler = require('./base')

class AICallingHandler extends BaseStateHandler {
  constructor() {
    super('ai_calling')
  }

  async process(task, db, cloud) {
    console.log(`🤖 调用AI: ${task._id}`)

    // ✅ 关键：不等待AI完成，只启动AI任务
    try {
      // 调用 aimodels，但不等待结果
      // 使用 context.callbackWaitsForEmptyEventLoop = false
      const result = await cloud.callFunction({
        name: 'aimodels',
        data: {
          action: 'startAIGeneration',  // 新接口：只启动不等待
          taskId: task._id,
          prompt: task.state_data.prompt,
          images: task.state_data.downloaded_images,
          parameters: task.params.parameters || {},
          type: task.type
        }
      })

      if (result.result && result.result.success) {
        // AI任务已启动
        const aiTaskId = result.result.data.ai_task_id

        // 更新状态为 ai_processing
        await this.updateState(task._id, 'ai_processing', {
          ...task.state_data,
          ai_task_id: aiTaskId,
          ai_start_time: new Date()
        }, db)

        return {
          message: 'AI generation started',
          ai_task_id: aiTaskId
        }
      } else {
        throw new Error('AI启动失败: ' + (result.result?.message || '未知错误'))
      }

    } catch (error) {
      console.error('AI调用失败:', error)
      await this.markFailed(task._id, error.message, db)
      throw error
    }
  }
}

module.exports = new AICallingHandler()
```

#### states/ai_processing.js (关键！)
```javascript
const BaseStateHandler = require('./base')

class AIProcessingHandler extends BaseStateHandler {
  constructor() {
    super('ai_processing')
  }

  async process(task, db, cloud) {
    console.log(`⏳ 检查AI状态: ${task._id}`)

    // ✅ 轮询检查AI是否完成
    try {
      const result = await cloud.callFunction({
        name: 'aimodels',
        data: {
          action: 'checkAIStatus',  // 新接口：检查AI状态
          taskId: task._id,
          aiTaskId: task.state_data.ai_task_id
        }
      })

      if (!result.result || !result.result.success) {
        // AI还在处理中，保持当前状态
        console.log(`AI还在处理中: ${task._id}`)

        // 检查是否超时（超过10分钟）
        const aiStartTime = new Date(task.state_data.ai_start_time)
        const elapsed = Date.now() - aiStartTime.getTime()

        if (elapsed > 10 * 60 * 1000) {
          throw new Error('AI处理超时（10分钟）')
        }

        return {
          message: 'AI still processing',
          elapsed_ms: elapsed
        }
      }

      // AI完成，获取结果
      const aiResult = result.result.data

      // 更新状态为 ai_completed
      await this.updateState(task._id, 'ai_completed', {
        ...task.state_data,
        ai_result: aiResult
      }, db)

      return {
        message: 'AI generation completed',
        images_count: aiResult.images?.length || 0
      }

    } catch (error) {
      console.error('检查AI状态失败:', error)
      await this.markFailed(task._id, error.message, db)
      throw error
    }
  }
}

module.exports = new AIProcessingHandler()
```

#### states/ai_completed.js
```javascript
const BaseStateHandler = require('./base')

class AICompletedHandler extends BaseStateHandler {
  constructor() {
    super('ai_completed')
  }

  async process(task, db, cloud) {
    console.log(`✅ AI完成，准备添加水印: ${task._id}`)

    // ai_completed → watermarking
    await this.updateState(task._id, 'watermarking', task.state_data, db)

    return {
      message: 'Ready for watermarking'
    }
  }
}

module.exports = new AICompletedHandler()
```

#### states/watermarking.js
```javascript
const BaseStateHandler = require('./base')

class WatermarkingHandler extends BaseStateHandler {
  constructor() {
    super('watermarking')
  }

  async process(task, db, cloud) {
    console.log(`🎨 添加水印: ${task._id}`)

    const aiResult = task.state_data.ai_result

    if (!aiResult || !aiResult.images || aiResult.images.length === 0) {
      throw new Error('没有AI生成的图片')
    }

    // 调用 aimodels 添加水印
    try {
      const result = await cloud.callFunction({
        name: 'aimodels',
        data: {
          action: 'addWatermarks',
          taskId: task._id,
          images: aiResult.images
        }
      })

      if (result.result && result.result.success) {
        const watermarkedImages = result.result.data.images

        // 更新状态为 uploading
        await this.updateState(task._id, 'uploading', {
          ...task.state_data,
          watermarked_images: watermarkedImages
        }, db)

        return {
          message: 'Watermarks added',
          images_count: watermarkedImages.length
        }
      } else {
        throw new Error('添加水印失败')
      }

    } catch (error) {
      console.error('添加水印失败:', error)
      await this.markFailed(task._id, error.message, db)
      throw error
    }
  }
}

module.exports = new WatermarkingHandler()
```

#### states/uploading.js
```javascript
const BaseStateHandler = require('./base')

class UploadingHandler extends BaseStateHandler {
  constructor() {
    super('uploading')
  }

  async process(task, db, cloud) {
    console.log(`📤 上传图片: ${task._id}`)

    const watermarkedImages = task.state_data.watermarked_images

    if (!watermarkedImages || watermarkedImages.length === 0) {
      throw new Error('没有待上传的图片')
    }

    // 调用 aimodels 上传图片
    try {
      const result = await cloud.callFunction({
        name: 'aimodels',
        data: {
          action: 'uploadImages',
          taskId: task._id,
          images: watermarkedImages,
          type: task.type
        }
      })

      if (result.result && result.result.success) {
        const finalImages = result.result.data.images

        // 更新 works 记录
        await db.collection('works').where({ task_id: task._id }).update({
          data: {
            status: 'completed',
            images: finalImages,
            completed_at: new Date(),
            updated_at: new Date()
          }
        })

        // 更新任务状态为 completed
        await db.collection('task_queue').doc(task._id).update({
          data: {
            state: 'completed',
            status: 'completed',
            state_data: {
              ...task.state_data,
              final_images: finalImages
            },
            completed_at: new Date(),
            updated_at: new Date()
          }
        })

        return {
          message: 'Task completed',
          images_count: finalImages.length
        }
      } else {
        throw new Error('上传图片失败')
      }

    } catch (error) {
      console.error('上传失败:', error)
      await this.markFailed(task._id, error.message, db)
      throw error
    }
  }
}

module.exports = new UploadingHandler()
```

---

## 🔧 aimodels 云函数改造

需要在 aimodels 中添加新接口：

1. `startAIGeneration` - 启动AI生成（不等待）
2. `checkAIStatus` - 检查AI状态
3. `addWatermarks` - 添加水印
4. `uploadImages` - 上传图片

---

## 📊 预期效果

### 优势

1. ✅ **彻底解决60秒超时**
   - 每个状态独立执行
   - 没有阻塞等待

2. ✅ **可处理任意长的AI任务**
   - AI调用后立即返回
   - 轮询检查状态

3. ✅ **高成功率**
   - 预估成功率 >95%
   - 有完整的重试机制

4. ✅ **清晰的状态追踪**
   - 每个状态都有明确记录
   - 易于监控和调试

### 响应时间

- 图片下载：30秒
- AI调用启动：10秒
- AI处理：30-120秒（轮询检查）
- 水印添加：30秒
- 图片上传：30秒

**总耗时**：2-4分钟（取决于AI速度）
**用户体验**：良好（有清晰的进度状态）

---

## 📝 实施清单

- [ ] 创建 state-processor 云函数
- [ ] 实现基础状态处理器类
- [ ] 实现 9 个状态处理器
- [ ] 改造 aimodels 云函数（添加新接口）
- [ ] 修改 photography/fitting（保持不变）
- [ ] 部署云函数
- [ ] 配置定时触发器
- [ ] 测试完整流程

---

**预计耗时**: 2-3小时（一次性完成）
**成功率预估**: 95%+
**用户体验**: 优秀

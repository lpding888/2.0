# 数据库触发器 + 异步处理方案设计

## 📋 当前流程分析

### 现有架构问题
```
小程序 → photography (30秒超时)
          ↓ (立即返回)
        photography-worker (60秒超时)
          ↓ (await 等待)
        aimodels (60秒超时)
          ↓ (立即返回)
        后台异步任务 ← 🔴 仍在 aimodels 的 60秒环境中！
          ↓
        HTTP请求 AI服务 (60秒超时) ← 🔴 瓶颈！
```

**核心问题**：
1. ❌ `aimodels` 的后台异步任务仍在原云函数的60秒限制内
2. ❌ AI服务处理超过60秒会超时失败
3. ❌ `ai-callback` 云函数已创建但未被使用
4. ⏱️ 前端使用轮询方式检查进度，不够实时

---

## 🎯 新方案架构

### 方案：数据库触发器 + 定时触发器组合

```
小程序提交任务
    ↓
创建 task_queue 记录 (status='pending')
    ↓
【数据库触发器】立即触发 → task-processor (600秒超时)
    ↓
处理AI任务（充足的时间）
    ↓
更新 task_queue 状态 (status='processing' → 'completed')
    ↓
【实时数据推送】前端 watch 监听 → 实时更新进度条 ✨
```

### 兜底机制：定时触发器
```
每分钟检查一次
    ↓
发现卡住的任务 (status='processing' 超过10分钟)
    ↓
重新处理或标记失败
```

---

## 🏗️ 实施方案

### 步骤1：改造 ai-callback 为 task-processor

**配置文件**：`cloudfunctions/task-processor/config.json`
```json
{
  "triggers": [
    {
      "name": "taskCleanup",
      "type": "timer",
      "config": "0 */1 * * * * *"
    }
  ],
  "timeout": 600,
  "permissions": {
    "openapi": []
  }
}
```

**功能**：
- 📥 接收数据库触发器事件
- 🔄 接收定时触发器调用（兜底）
- ⏱️ 600秒超时，足够处理AI任务
- 🎨 处理完成后更新数据库

---

### 步骤2：配置数据库触发器

**在微信云开发控制台配置**：
1. 进入：设置 → 其他设置 → 事件触发列表
2. 点击"添加事件触发"
3. 配置：
   - **监听集合**：`task_queue`
   - **触发事件**：文档创建 + 文档更新
   - **触发条件**：`status == 'pending'` 或 `status == 'ai_processing'`
   - **目标云函数**：`task-processor`

---

### 步骤3：修改前端为实时监听

**文件**：`miniprogram/pages/works/works.js`

**添加实时监听**：
```javascript
// 在 onLoad 中启动监听
const db = wx.cloud.database()

// 监听当前用户的作品变化
this.watcher = db.collection('works')
  .where({
    user_openid: app.globalData.userInfo.openid
  })
  .watch({
    onChange: (snapshot) => {
      console.log('📡 实时数据推送:', snapshot)

      // 更新本地数据
      snapshot.docChanges.forEach(change => {
        if (change.queueType === 'update') {
          this.updateWorkInList(change.doc)
        }
      })
    },
    onError: (err) => {
      console.error('❌ 监听出错:', err)
    }
  })

// 在 onUnload 中关闭监听
if (this.watcher) {
  this.watcher.close()
}
```

**好处**：
- ✅ 实时推送，无延迟
- ✅ 减少轮询请求，节省资源
- ✅ 进度条实时更新
- ✅ 更好的用户体验

---

## 📝 详细实施步骤

### 第一阶段：重构 task-processor 云函数

#### 1.1 重命名并配置
```bash
cd cloudfunctions
mv ai-callback task-processor
cd task-processor
```

#### 1.2 创建 config.json
```json
{
  "triggers": [
    {
      "name": "taskCleanup",
      "type": "timer",
      "config": "0 */1 * * * * *"
    }
  ],
  "timeout": 600
}
```

#### 1.3 修改 package.json
```json
{
  "name": "task-processor",
  "version": "1.0.0",
  "cloudfunction-config": {
    "timeout": 600,
    "envVariables": {},
    "permissions": {
      "openapi": []
    }
  }
}
```

#### 1.4 重写 index.js

**核心逻辑**：
```javascript
exports.main = async (event, context) => {
  console.log('🚀 task-processor 被触发:', event)

  // 判断触发类型
  if (event.triggerName === 'taskCleanup') {
    // 定时触发器调用 - 兜底清理
    return await handleTimerTrigger()
  } else if (event.docId) {
    // 数据库触发器调用 - 实时处理
    return await handleDatabaseTrigger(event)
  } else {
    // 手动调用
    return await handleManualCall(event)
  }
}

// 处理数据库触发器
async function handleDatabaseTrigger(event) {
  const { docId, doc } = event

  // 只处理 pending 或 ai_processing 状态的任务
  if (doc.status !== 'pending' && doc.status !== 'ai_processing') {
    return { success: true, message: '跳过非待处理任务' }
  }

  console.log('📥 处理任务:', docId)

  // 标记为处理中
  await db.collection('task_queue').doc(docId).update({
    data: {
      status: 'processing',
      processing_started_at: new Date(),
      updated_at: new Date()
    }
  })

  // 调用 AI 处理（有600秒时间）
  const result = await processAITask(doc)

  return result
}

// 处理定时触发器（兜底）
async function handleTimerTrigger() {
  const db = cloud.database()
  const _ = db.command

  // 查找卡住的任务（processing 状态超过10分钟）
  const stuckTasks = await db.collection('task_queue')
    .where({
      status: 'processing',
      processing_started_at: _.lt(new Date(Date.now() - 10 * 60 * 1000))
    })
    .limit(10)
    .get()

  console.log('🔍 发现卡住的任务:', stuckTasks.data.length)

  // 重新处理或标记失败
  for (const task of stuckTasks.data) {
    await handleStuckTask(task)
  }

  return { success: true, processed: stuckTasks.data.length }
}

// 实际的AI处理逻辑
async function processAITask(task) {
  try {
    // 调用现有的 WorkflowOrchestrator
    const WorkflowOrchestrator = require('../aimodels/modules/workflowOrchestrator')
    const orchestrator = new WorkflowOrchestrator()

    const result = await orchestrator.executeGenerationWorkflow({
      taskId: task._id,
      imageIds: task.params.images,
      prompt: task.params.prompt || '生成图片',
      parameters: task.params.parameters || {},
      type: task.type
    })

    if (result.success) {
      // 更新为完成状态
      await db.collection('task_queue').doc(task._id).update({
        data: {
          status: 'completed',
          completed_at: new Date(),
          updated_at: new Date()
        }
      })
    } else {
      // 更新为失败状态
      await db.collection('task_queue').doc(task._id).update({
        data: {
          status: 'failed',
          error: result.message,
          failed_at: new Date(),
          updated_at: new Date()
        }
      })
    }

    return result

  } catch (error) {
    console.error('❌ AI处理失败:', error)

    // 更新为失败状态并退还积分
    await handleTaskFailure(task._id, error.message)

    return { success: false, message: error.message }
  }
}
```

---

### 第二阶段：修改现有流程

#### 2.1 简化 photography.js
```javascript
// 移除调用 photography-worker
// 只需要创建 task_queue 记录即可

// 创建任务记录
await db.collection('task_queue').add({
  data: {
    _id: taskId,
    user_openid: OPENID,
    type: 'photography',
    status: 'pending',  // 数据库触发器会自动处理
    params: { images, parameters, sceneId, count },
    created_at: new Date()
  }
})

// 立即返回
return {
  success: true,
  data: { task_id: taskId, work_id: workResult._id },
  message: '任务已提交'
}
```

#### 2.2 修改 AICaller 超时
```javascript
// cloudfunctions/aimodels/modules/aiCaller.js
constructor() {
  this.timeout = 300000  // 5分钟超时（task-processor 有600秒）
}
```

---

### 第三阶段：前端实时监听

#### 3.1 修改 works.js

**添加实时监听**：
```javascript
data: {
  works: [],
  // 移除 pollingTimer 相关
},

onLoad() {
  this.loadWorks()
  this.startRealtimeWatch()  // 启动实时监听
},

onUnload() {
  this.stopRealtimeWatch()  // 停止监听
},

// 启动实时监听
startRealtimeWatch() {
  const db = wx.cloud.database()
  const app = getApp()

  if (!app.globalData.userInfo?.openid) {
    console.warn('用户未登录，跳过实时监听')
    return
  }

  console.log('📡 启动作品实时监听')

  this.watcher = db.collection('works')
    .where({
      user_openid: app.globalData.userInfo.openid
    })
    .watch({
      onChange: (snapshot) => {
        console.log('📡 收到数据变化:', snapshot)
        this.handleRealtimeUpdate(snapshot)
      },
      onError: (err) => {
        console.error('❌ 实时监听错误:', err)
        // 降级到轮询
        this.fallbackToPolling()
      }
    })
},

// 停止实时监听
stopRealtimeWatch() {
  if (this.watcher) {
    console.log('🔌 关闭实时监听')
    this.watcher.close()
    this.watcher = null
  }
},

// 处理实时更新
handleRealtimeUpdate(snapshot) {
  snapshot.docChanges.forEach(change => {
    const work = change.doc

    switch (change.queueType) {
      case 'init':
        // 初始化数据，不处理
        break

      case 'update':
        // 更新作品
        this.updateWorkInList(work)

        // 如果是刚完成的作品，显示通知
        if (work.status === 'completed') {
          wx.showToast({
            title: '作品生成完成',
            icon: 'success'
          })
        }
        break

      case 'add':
        // 新增作品
        this.addWorkToList(work)
        break

      case 'remove':
        // 删除作品
        this.removeWorkFromList(work._id)
        break
    }
  })
},

// 更新列表中的作品
updateWorkInList(work) {
  const index = this._works.findIndex(w => w._id === work._id)
  if (index !== -1) {
    this._works[index] = work
    this.setDataSafe({ works: this._works })
  }
},

// 降级到轮询（兜底）
fallbackToPolling() {
  console.warn('⚠️ 实时监听失败，降级到轮询模式')
  // 启动原有的轮询逻辑
}
```

#### 3.2 添加进度条实时更新

**WXML 中显示实时状态**：
```xml
<view class="work-status">
  <block wx:if="{{work.status === 'pending'}}">
    <text>⏳ 排队中...</text>
  </block>
  <block wx:elif="{{work.status === 'processing'}}">
    <text>🔄 AI处理中...</text>
    <progress percent="50" active stroke-width="3"/>
  </block>
  <block wx:elif="{{work.status === 'completed'}}">
    <text>✅ 已完成</text>
  </block>
  <block wx:elif="{{work.status === 'failed'}}">
    <text>❌ 生成失败</text>
  </block>
</view>
```

---

## ✅ 优势对比

### 旧方案（轮询）
- ⏱️ 30秒-1分钟延迟
- 📡 频繁请求，浪费资源
- ❌ 60秒超时限制
- 🔋 耗费用户流量

### 新方案（实时+触发器）
- ⚡ 实时响应，0延迟
- 💡 事件驱动，按需触发
- ✅ 600秒超时，足够处理
- 🎯 节省资源和流量

---

## 🔍 测试验证

### 测试场景
1. **快速响应**：提交任务后立即开始处理
2. **长时间处理**：AI处理超过60秒能否成功
3. **实时更新**：前端能否实时收到状态变化
4. **失败恢复**：定时器能否捕获卡住的任务
5. **并发处理**：多个任务同时提交

### 测试步骤
```bash
# 1. 部署云函数
npm run deploy:task-processor

# 2. 配置数据库触发器（控制台）

# 3. 提交测试任务

# 4. 观察日志
# - 数据库触发器日志
# - task-processor 执行日志
# - 前端 watch 回调日志

# 5. 验证超时场景
# - 模拟AI服务响应慢（120秒）
# - 验证任务能否成功完成
```

---

## 📅 实施计划

### Day 1: 云函数改造
- [ ] 重命名 ai-callback 为 task-processor
- [ ] 添加 config.json 配置
- [ ] 重写 index.js 逻辑
- [ ] 修改 AICaller 超时时间
- [ ] 本地测试

### Day 2: 配置触发器
- [ ] 在控制台配置数据库触发器
- [ ] 测试触发器是否生效
- [ ] 验证600秒超时配置
- [ ] 测试长时间AI任务

### Day 3: 前端改造
- [ ] 添加 watch 监听
- [ ] 移除旧的轮询代码
- [ ] 添加降级兜底逻辑
- [ ] UI适配实时更新

### Day 4: 简化流程
- [ ] 简化 photography.js
- [ ] 简化 fitting.js
- [ ] 移除 photography-worker（可选）
- [ ] 清理冗余代码

### Day 5: 测试上线
- [ ] 完整功能测试
- [ ] 性能测试
- [ ] 压力测试
- [ ] 灰度发布

---

## 🚨 注意事项

1. **数据库触发器限制**
   - 确认控制台支持配置触发条件
   - 验证触发器是否有调用频率限制

2. **watch 监听**
   - 基础库版本要求：2.11.2+
   - 需要在 onUnload 中关闭监听
   - 注意内存泄漏

3. **兼容性处理**
   - 旧代码保留，逐步迁移
   - 添加降级方案
   - 保留手动重试功能

4. **成本考虑**
   - 实时数据推送有配额限制
   - 定时触发器按调用次数计费
   - 评估实际成本

---

## 📚 参考文档

- [微信云开发 - 实时数据推送](https://developers.weixin.qq.com/minigame/dev/wxcloud/guide/database/realtime.html)
- [微信云开发 - 数据库事件触发器](https://developers.weixin.qq.com/minigame/dev/wxcloud/guide/functions/EveTrigger.html)
- [微信云开发 - 定时触发器](https://developers.weixin.qq.com/minigame/dev/wxcloud/guide/functions/triggers.html)
- [云函数超时配置](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/functions/config.html)

---

## 🎉 预期效果

实施后：
- ⚡ **实时响应**：用户提交任务后立即开始处理
- 🎯 **稳定可靠**：600秒超时足够AI完成处理
- 📱 **用户体验**：进度条实时更新，无需刷新
- 💰 **成本优化**：减少无效轮询，节省资源
- 🛡️ **兜底保障**：定时器处理异常情况

---

**更新时间**：2025-10-01 深夜
**状态**：设计完成，待实施

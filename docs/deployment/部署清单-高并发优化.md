# 高并发架构部署清单

## ✅ 关键Bug修复（2025-10-01）

### Bug #1: Worker中的async IIFE导致容器提前终止

**问题描述**：
之前的代码使用了async IIFE（立即执行的异步函数）模式，但在微信云函数中，当主函数return时，容器会立即终止，导致异步代码被杀死。

**错误日志**：
- photography-worker返回时间：2.7秒
- 但AI生成需要60-120秒
- 图片从未被发送给AI API

**原因**：
```javascript
// 错误代码：
;(async () => {
  await imageProcessor.downloadAndConvert(...)  // 这里被杀死
  await aiCaller.generateImages(...)  // 从未执行
})()
return  // ← 容器立即终止！
```

**修复方案**：
移除async IIFE，直接await所有操作：
```javascript
// 正确代码：
const aiProcessedImages = await imageProcessor.downloadAndConvert(...)
const aiResult = await aiCaller.generateImages(...)
// ... 等待全部完成后才返回
```

**影响文件**：
- ✅ `cloudfunctions/photography-worker/index.js` (Lines 250-340)
- ✅ `cloudfunctions/fitting-worker/index.js` (Lines 385-483)

---

### Bug #2: photography/fitting等待worker超时

**问题描述**：
photography和fitting使用`await cloud.callFunction()`等待worker返回，但worker需要46秒（甚至60-120秒），而callFunction默认15秒超时。

**错误日志**：
```
photography-worker实际运行: 46秒 ✅ 成功完成
photography等待超时: 15秒 ❌ ESOCKETTIMEDOUT
结果: photography认为失败，退还积分，但worker已生成图片
```

**原因**：
```javascript
// 错误代码：
await cloud.callFunction({
  name: 'photography-worker',
  data: {...}
})
// ↑ 这会等待worker返回，但worker需要46秒，15秒就超时
```

**修复方案**：
使用fire-and-forget模式，不等待worker返回，并区分超时和真正的启动失败：
```javascript
// 正确代码：
cloud.callFunction({
  name: 'photography-worker',
  data: {...}
}).then(() => {
  console.log('✅ worker调用成功（将在独立容器中运行）')
}).catch((error) => {
  // 区分超时错误和真正的启动失败
  const isTimeout = error.message && (
    error.message.includes('ESOCKETTIMEDOUT') ||
    error.message.includes('timeout') ||
    error.message.includes('ETIMEDOUT')
  )

  if (isTimeout) {
    console.log('⚠️ Worker调用超时，但worker可能仍在运行，不标记失败')
    return // 超时不算失败，让worker自己处理
  }

  // 真正的启动错误（如配额不足、权限错误）才标记失败并退还积分
  console.error('❌ Worker真正启动失败')
  // ... 退还积分并标记失败
})

// 立即返回task_id给用户，不等待worker完成
return { success: true, data: { task_id } }
```

**影响文件**：
- ✅ `cloudfunctions/photography/index.js` (Lines 179-230)
- ✅ `cloudfunctions/fitting/index.js` (Lines 193-245)

**用户体验变化**：
- 用户提交后立即收到task_id（<1秒）
- worker在独立容器中运行60-120秒
- 用户通过轮询getProgress查看进度
- 超时不再被误判为失败
- 只有真正的启动错误才会失败和退还积分

---

### Bug #3: images参数被parameters覆盖

**问题描述**：
用户上传的图片虽然被下载和处理了，但没有发送给AI API，导致AI只能根据文字提示词生成图片，无法参考用户上传的服装图片。

**错误日志**：
```
行542: 🖼️ 输入图片数量: 2  ✅ images参数有2张图片
行551-554: ✅ 转换第1,2张图片  ✅ 图片被成功转换
行563: has_images: false  ❌ 发送给API时没有图片
```

**原因**：
在 `aiCaller.js` 的 `prepareAPIParams` 方法中：
```javascript
// 错误代码：
return {
  prompt: String(prompt || ''),
  images: convertedImages,     // 设置图片
  ...(parameters || {})         // 展开parameters
}
// 问题：如果parameters中也有images字段，会覆盖前面的convertedImages！
```

**修复方案**：
从parameters中排除images字段，避免覆盖：
```javascript
// 正确代码：
const { images: _unused, ...cleanParameters } = parameters || {}

return {
  prompt: String(prompt || ''),
  images: convertedImages,      // 来自函数参数的已处理图片
  ...cleanParameters             // 展开其他参数，不包含images
}
```

**影响文件**：
- ✅ `cloudfunctions/photography-worker/modules/aiCaller.js` (Lines 544-556)
- ✅ `cloudfunctions/fitting-worker/modules/aiCaller.js` (Lines 544-556)

**修复效果**：
- 用户上传的服装图片会正确发送给AI API
- AI生成的图片会参考用户上传的服装款式
- 不再生成与用户上传图片无关的内容

---

### Bug #4: 图片被双重转换导致丢失

**问题描述**：
修复Bug #3后，发现图片仍然没有发送给AI API。日志显示图片转换成功但API配置显示`has_images: false`。

**错误日志**：
```
行261: 🔄 转换 2 张图片格式为API期望格式  ✅ 第一次转换
行263: ✅ 转换第1张图片: 67KB
行263: ✅ 转换第2张图片: 75KB
行263: 🔄 转换 2 张图片格式为API期望格式  ❌ 第二次转换！
行264: 📊 API配置: { has_images: false }  ❌ 图片丢失
```

**原因**：
在 photography-worker/index.js 中预先调用了一次转换：
```javascript
// 错误代码：
const aiProcessedImages = await imageProcessor.downloadAndConvert(event.images || [])
const apiImages = aiCaller.convertImagesForAPI(aiProcessedImages)  // 第一次转换

await aiCaller.generateImages({
  images: apiImages  // apiImages 已经是 {url, width, height} 格式
})
```

然后在 aiCaller.prepareAPIParams 中又转换一次：
```javascript
prepareAPIParams(model, prompt, parameters, images = []) {
    const convertedImages = this.convertImagesForAPI(images)  // 第二次转换
    // convertImagesForAPI 期望 {status: 'success', base64Url: '...'} 格式
    // 但收到的是 {url: '...', width: 1024} 格式
    // 因为没有 status 字段，过滤后返回空数组
}
```

**修复方案**：
移除 photography-worker 中的预先转换，直接传递原始格式：
```javascript
// 正确代码：
const aiProcessedImages = await imageProcessor.downloadAndConvert(event.images || [])

await aiCaller.generateImages({
  images: aiProcessedImages  // 传递原始格式，让 prepareAPIParams 统一转换
})
```

**影响文件**：
- ✅ `cloudfunctions/photography-worker/index.js` (Lines 258-268)
- ✅ `cloudfunctions/fitting-worker/index.js` (Lines 401-411)

**修复效果**：
- 图片只转换一次，保持正确格式
- `has_images: true`，图片正确发送给AI API
- AI能够参考用户上传的服装图片生成结果

---

### Bug #5: callFunction超时导致状态覆盖

**问题描述**：
即使worker成功完成并返回图片，前端仍显示"任务失败"。原因是callFunction在15秒时超时触发catch块，把已完成的任务标记为失败。

**竞态条件时间线**：
```
T=0秒:  photography 异步调用 worker
T=0秒:  photography 返回 success: true  ✅
T=0秒:  前端跳转到 works 页面  ✅
T=15秒: callFunction 超时 → catch 块执行 → 标记 failed  ❌
T=46秒: worker 完成 → 更新为 completed  ✅
T=47秒: catch 块可能覆盖 completed → 最终状态 failed  ❌
```

**原因**：
```javascript
// 问题代码：
cloud.callFunction({...}).catch((error) => {
  // 15秒超时触发这里
  db.collection('task_queue').doc(taskId).update({
    data: { status: 'failed' }  // ← 可能覆盖worker的completed状态
  })
})
```

**修复方案**：
区分超时错误和真正的启动失败，超时时不做任何操作：
```javascript
// 正确代码：
cloud.callFunction({...}).catch(async (error) => {
  // 区分超时错误和真正的启动失败
  const isTimeout = error.message && (
    error.message.includes('ESOCKETTIMEDOUT') ||
    error.message.includes('timeout') ||
    error.message.includes('ETIMEDOUT')
  )

  if (isTimeout) {
    console.log('⚠️ Worker调用超时，但worker可能仍在运行，不标记失败')
    return  // 超时不算失败，让worker自己更新状态
  }

  // 只有真正的启动失败才标记失败和退还积分
  db.collection('task_queue').doc(taskId).update({
    data: { status: 'failed' }
  })
})
```

**影响文件**：
- ✅ `cloudfunctions/photography/index.js` (Lines 198-230)
- ✅ `cloudfunctions/fitting/index.js` (Lines 213-245)

**修复效果**：
- Worker成功完成的任务不会被误标记为失败
- 前端正确显示任务状态（completed）
- 用户能看到成功生成的图片

---

## ⚠️ 重要前置步骤：配置环境变量

所有worker需要配置API密钥环境变量（与aimodels相同）：

### 在云开发控制台配置：
1. **photography-worker** 环境变量：
   - 复制 aimodels 的所有环境变量
   - 例如：`GEMINI_API_KEY = AIzaSy...`

2. **fitting-worker** 环境变量：
   - 复制 aimodels 的所有环境变量
   - 例如：`GEMINI_API_KEY = AIzaSy...`

**原因**：worker 的 aiCaller 模块需要读取 API 密钥

---

## 需要部署的云函数（按顺序）

### 1. aimodels （保留模型选择功能）
**改动**：
- 保留 selectBestModel（轻量查询）
- worker 依赖此函数选择AI模型

### 2. photography-worker （新增依赖 + 环境变量）
```bash
cd cloudfunctions/photography-worker
npm install
```
**改动**：
- 新增 modules/ 目录（复制自aimodels）
- 改造为独立AI处理
- 新增依赖：axios

### 3. fitting-worker （新增依赖 + 环境变量）
```bash
cd cloudfunctions/fitting-worker
npm install
```
**改动**：
- 新增 modules/ 目录（复制自aimodels）
- 改造为独立AI处理
- 新增依赖：axios

### 4. photography （修改调用方式）
**改动**：
- 从调用 task-processor 改为直接调用 photography-worker
- 新增 worker 启动失败时的积分退还逻辑

### 5. fitting （修改调用方式）
**改动**：
- 从调用 task-processor 改为直接调用 fitting-worker
- 新增 worker 启动失败时的积分退还逻辑

### 6. task-processor （可选，未来扩展用）
**改动**：
- ai_calling.js 改为调用独立worker
- 当前架构下不再使用，但保留用于未来扩展

---

## 部署命令

### 使用微信开发者工具：
1. **先配置环境变量**（云开发控制台 → 云函数 → 环境变量）：
   - photography-worker: 复制 aimodels 的环境变量
   - fitting-worker: 复制 aimodels 的环境变量

2. 依次右键上传以下云函数：
   - aimodels
   - photography-worker
   - fitting-worker
   - photography
   - fitting

### 或使用命令行（如果配置了CLI）：
```bash
# 1. 安装 worker 依赖
cd cloudfunctions/photography-worker && npm install && cd ../..
cd cloudfunctions/fitting-worker && npm install && cd ../..

# 2. 在云开发控制台配置环境变量（手动操作）
# photography-worker 和 fitting-worker 需要与 aimodels 相同的环境变量

# 3. 上传云函数
tcb fn deploy aimodels
tcb fn deploy photography-worker
tcb fn deploy fitting-worker
tcb fn deploy photography
tcb fn deploy fitting
```

---

## 不需要部署的函数

- ❌ task-processor（可选，当前不使用）
- ❌ api（未修改）
- ❌ 其他云函数（未修改）

---

## 测试验证

### 1. 测试单个用户
- 前端发起摄影请求
- 检查日志：photography-worker 是否启动
- 等待AI完成（60-120秒）
- 检查 works 表是否有 fileID

### 2. 测试并发（关键）
- **同时发起 5-10 个请求**
- 检查日志：应该看到多个 photography-worker 实例同时运行
- 所有任务应该并行处理，不会相互阻塞

### 3. 检查性能指标
- photography.generate() 响应时间：< 5秒
- worker 容器占用时间：60-120秒（正常）
- 并发能力：支持 10+ 用户同时使用

---

## 回滚方案

如果出现问题，保留的备份文件：
- `photography-worker/index.js` 原始版本（调用 createGenerationTask）
- `photography/index.js` 原始版本（调用 task-processor）
- `fitting-worker/index.js` 原始版本
- `fitting/index.js` 原始版本

可随时恢复旧版本并重新部署。

---

## 预期效果

### 性能提升
- ✅ 响应时间：从不确定 → 稳定 <5秒
- ✅ 并发能力：从排队等待 → 并行处理
- ✅ 容器利用率：从阻塞 → 高效

### 用户体验
- ✅ 提交任务立即返回
- ✅ 多个用户不会相互影响
- ✅ 失败时自动退还积分
